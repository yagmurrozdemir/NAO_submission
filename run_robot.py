# Choregraphe Python box: PlayPlannedSequence (Option B, with argv fix)
# Runs INSIDE Choregraphe (Python 2.7, NAOqi OK).
# It reads sequence.txt and executes each motion script via execfile().

import os
import time                     # <-- ADDED
from naoqi import ALProxy
import sys as _sys
import os as _os


class MyClass(GeneratedClass):
    def __init__(self):
        GeneratedClass.__init__(self)

        # >>> ADJUST THESE PATHS IF NEEDED <<<
        # Path to the sequence.txt generated by play_sequence.py
        self.sequence_path = "/Users/ayselyagmur/NAO_planning_chore/sequence.txt"
        # Folder containing the teacher motion scripts <file_id>.py
        self.motions_dir   = "/Users/ayselyagmur/NAO_planning_chore/motions"

        # Robot IP and port (the NAO you are connected to from Choregraphe)
        self.robot_ip   = "127.0.0.1"
        self.robot_port = 9559

    def onLoad(self):
        pass

    def onUnload(self):
        pass

    def _say(self, msg):
        """Helper: speak and also print to console."""
        try:
            tts = ALProxy("ALTextToSpeech")
            tts.say(msg)
        except Exception, e:
            print "[PlayPlannedSequence] TTS error:", e
        print "[PlayPlannedSequence]", msg

    def onInput_onStart(self):
        self._say("Planner box started")

        # 1) Check sequence.txt exists
        if not os.path.exists(self.sequence_path):
            self._say("Sequence file not found")
            self._say(self.sequence_path)
            self.onStopped()
            return

        # 2) Read sequence.txt lines
        try:
            with open(self.sequence_path, "r") as f:
                lines = [l.strip() for l in f.readlines() if l.strip()]
        except Exception, e:
            self._say("Error reading sequence file")
            print "[PlayPlannedSequence] read error:", e
            self.onStopped()
            return

        if not lines:
            self._say("Sequence file is empty")
            self.onStopped()
            return

        # ---- NEW: first line = speed_factor (if it parses as float) ----
        try:
            speed_factor = float(lines[0])
            motion_ids = lines[1:]
            self._say("Using speed_factor = %.2f" % speed_factor)
        except Exception:
            # Backwards-compatible: no speed line, treat all as motions
            speed_factor = 1.0
            motion_ids = lines
            self._say("No valid speed factor in first line; using speed_factor = 1.0")

        if not motion_ids:
            self._say("No motions found after speed factor line")
            self.onStopped()
            return

        self._say("Loaded %d motions" % len(motion_ids))

        # Try to configure global speed factor on ALMotion
        try:
            motion_proxy = ALProxy("ALMotion", self.robot_ip, self.robot_port)
            motion_proxy.setMotionConfig([["ENABLE_JOINT_SPEED_RATIO", speed_factor]])
        except Exception, e:
            self._say("Could not set global speed factor on ALMotion")
            print "[PlayPlannedSequence] ALMotion config error:", e
            # We still continue; scripts may set their own speeds.

        # --- list to store measured durations ---
        durations = []

        # 3) Execute each motion script in order
        for file_id in motion_ids:
            script_path = os.path.join(self.motions_dir, file_id + ".py")
            self._say("Executing " + file_id)

            if not os.path.exists(script_path):
                self._say("Script missing " + file_id)
                continue

            # Emulate CLI args for scripts that use sys.argv or os.argv
            argv_list = [script_path, self.robot_ip, str(self.robot_port)]
            _sys.argv = argv_list
            _os.argv  = argv_list  # in case they wrongly use os.argv

            # Global namespace for the script
            g = {
                "__name__": "__main__",       # so their "if __name__ == '__main__'" works
                "__file__": script_path,
                "robotIP": self.robot_ip,     # common naming in NAO examples
                "robotPort": self.robot_port,
                "ROBOT_IP": self.robot_ip,    # extra aliases, harmless
                "ROBOT_PORT": self.robot_port,
                "sys": _sys,
                "os": _os,
            }

            try:
                # --- timing around execfile ---
                start = time.time()
                execfile(script_path, g, g)
                end = time.time()
                duration = end - start
                durations.append((file_id, duration))
                # (no extra speech here to keep behavior identical)
            except Exception, e:
                self._say("Error in script " + file_id)
                self._say(str(e))
                print "[PlayPlannedSequence] ERROR executing", file_id, ":", e

        # --- write durations to a file next to motions ---
        out_path = os.path.join(self.motions_dir, "measured_durations.txt")
        try:
            with open(out_path, "w") as f:
                for fid, d in durations:
                    f.write("%s %.3f\n" % (fid, d))
            print "[PlayPlannedSequence] Durations saved to", out_path
        except Exception, e:
            self._say("Could not write durations file")
            print "[PlayPlannedSequence] ERROR writing durations:", e

        self._say("Finished all motions")
        self.onStopped()
